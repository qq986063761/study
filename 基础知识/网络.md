# OSI 七层模型（Open System Interconnect：开放系统互连参考模型）
- 应用层：向应用程序提供服务，如：http、ftp、smtp
- 表示层：处理应用层数据传递给会话层（转换数据为网络标准格式、压缩、加密），如：ASCII、SSL/TLS
- 会话层：建立连接、维护和协调数据通信
- 传输层：为会话层和网络层提供传输服务如：TCP、UDP，也能指定通信端口
- 网络层：负责寻址和路由选择，如：IP、ICMP
- 数据链路层：将网络层数据封装成帧，传递给物理层或接收物理层的数据帧，如：ARP、PPP、SLIP
- 物理层：负责比特流（0，1）和电信号（电压高低）、光信号（光的闪灭）的转换，如：线缆、网卡、调制解调器、集线器

# DNS（域名系统、域名解析）
- 作用：域名和 ip 地址的互相解析
- 解析过程：
  - 客户机向 dns 服务器发送域名，请求查询对应 ip 地址
  - 当 dns 服务器查不到，则继续向其他 dns 服务器迭代查询，直到查到结果

# UDP（用户数据报协议）
- 特点：
  - 无连接：传数据不需要先连接
  - 不可靠：无法确定数据是否收到，不检查安全性，没有拥塞控制数据可能丢失
  - 高效：因为上面两点所以高效
- 适合场景（用户不关心之前的状态，只关心当前的状态）：直播

# TCP（传输控制协议）
- 可靠性
  - 乱序重建，对数据包编号排序，让对方可以重新还原顺序；
  - 丢包重试，发送方未得到响应的数据，会重新发送避免丢包；
- 头标识符：
  - URG=1：表示数据部分含紧急信息
  - ACK=1：表示确认
  - PSH=1：表示接收端应该立即将数据 push 给应用层，而不是等到缓冲区满后再提交
  - RST=1：表示连接出现问题，可能需要重新建立连接；也可用于拒绝连接
  - SYN=1：当 ACK=0 时，表示请求连接；否则表示是同意建立连接的回复报文
  - FIN=1：表示要释放连接
- 三次握手（开启连接）：
  - 客户端：发送数据包（SYN=1，Seq=X）告诉服务端需要创建连接；
  - 服务端：发送数据包（SYN=1，ACK=X+1，Seq=Y）告诉客户端确认收到请求，可以开始创建连接；
  - 客户端：发送数据包（ACK=Y+1，Seq=Z）告诉服务端确认收到反馈，然后开始创建连接；
- 为什么需要三次握手：避免不必要的开销，待双方确认可以连接后开始传递数据，否则如果服务端反馈信息告诉客户端出现问题无法连接，客户端还在发送数据造成不必要的开销
- 四次挥手（断开连接）：
  - 客户端：发送数据包（FIN=1，Seq=X）告诉服务端需要关闭连接
  - 服务端：发送数据包（ACK=X+1，Seq=Z）告诉客户端确认收到请求，但是服务端可能还在发送数据
  - 服务端：发送数据包（FIN=1，ACK=X，Seq=Y）告诉客户端可以关闭连接
  - 客户端：发送数据包（ACK=Y，Seq=X）告诉服务端确认收到信息，然后关闭连接，最后服务端也关闭连接

# TCP/IP 协议（传输控制协议/互联网协议）
- 概念：一个网络通讯协议，定义了电子设备连入因特网，和数据传输的标准；
- IP 地址分类：
  - A 类：最大网络数：126（2 的 7 次方 - 2），ip 地址在 1.0.0.0 至 126.255.255.255，最大主机数在 2 的 24 次方减 2 个，私有（内网）ip 地址在 10.0.0.0 至 10.255.255.255；
  - B 类：最大网络数：16384（2 的 14 次方），ip 地址在 128.0.0.0 至 191.255.255.255，最大主机数在 2 的 16 次方减 2 个，私有（内网）ip 地址在 172.16.0.0 至 172.31.255.255；
  - C 类：最大网络数：2097152（2 的 21 次方），ip 地址在 192.0.0.0 至 223.255.255.255，最大主机数在 2 的 8 次方减 2 个，私有（内网）ip 地址在 192.168.0.0 至 192.168.255.255；
- 子网掩码：掩码中 255 对应的 ip 地址不同，则说明网段不同，剩余位不同只能说明是同一个网段内不同ip
  - A 类网段子网掩码：255.0.0.0
  - B 类网段子网掩码：255.255.0.0
  - C 类网段子网掩码：255.255.255.0
- 常见端口：
  - ftp（文件传输协议）：20、21
  - ssh（安全 shell 协议）：22
  - telnet（远程登录协议）：23
  - dns（域名系统）：53
  - http（超文本传输协议）：80
  - smtp（简单邮件传输协议）：25
  - pop3（邮局协议 3 代）：110

# HTTP（超文本传输协议）
- 请求方法
  - GET：用于获取服务器资源
    - 参数在 url 中，不安全，有长度限制，参数会保留在浏览器历史记录中
    - 请求会被浏览器主动缓存，所以回退浏览器 url 不用重新发请求
    - 只能对 url 进行编码
    - 只接受 ASCII 字符
    - 产生一个 tcp 数据包（数据在url中同时发送）
  - POST：用于向服务器提交数据
    - 参数在 Request body 中，相对 get 请求安全，没大小限制，参数不会保留在浏览器历史记录中
    - 回退浏览器 url 时，会重新发请求
    - 支持多种编码格式
    - 产生 2 个 tcp 数据包（先发送 header 部分，服务器响应 100，然后再发送 data）
  - PUT：向服务器提交数据，通常指定了资源的存放位置；
  - DELETE：用于删除资源；
  - HEAD：获取资源，不呈现请求参数，只带请求头；
  - TRACE：请求返回服务器获取到的数据信息，常用来测试和诊断信息；
  - OPTIONS：预请求，浏览器对于跨域请求安全的检测，用于获取当前请求所支持的方法，请求成功后返回所支持的方法（get、post 等等），然后再发送实际的请求；
- HTTP版本
  - HTTP/1
    - 0.9：只允许 get 请求，不支持请求头
    - 1.0：支持请求头，get、post、head 方法，支持长连接（默认短连接）
    - 1.1：默认 keep-alive（长连接），OPTIONS,PUT, DELETE, TRACE 方法，断点续传、身份认证、状态管理、缓存
    - 不足：每次请求带重复 header 数据，浏览器同域请求数限制会阻塞请求
  - HTTP/2：数据二进制传输（以前是文本）；header 压缩；服务端推送（客户端请求后主动推送资源）；多路复用（一个 tcp 连接可传输所有请求数据）
  - HTTP/3：QUIC 协议（基于 UDP）代替 TCP 协议，达到又快又可靠的好处；
- 头字段：
  - Cache-Control：控制缓存
  - Accept：请求头希望接收数据的类型
  - Content-Type：响应头记录的返回数据类型
- 状态码：
  - 1xx：提示信息
  - 2xx：成功
    - 200：请求成功，服务端成功处理
    - 202：请求成功，服务端未处理
    - 204：请求成功，没返回内容
  - 3xx：重定向
    - 301：永久重定向
    - 302：临时重定向
    - 304：浏览器可直接取缓存
  - 4xx：客户端错误
    - 400：请求方语法错误
    - 401：需要请求方的 http 认证信息
    - 403：服务器拒绝访问
    - 404：目标不存在
  - 5xx：服务端错误

# 缓存
- Memory Cache：浏览器最先尝试查找的缓存区域，响应速度最快，生命周期短（tab 关闭后数据消失），通常 base64 图片、体积不大的 js、css 文件比较容易被写入到内存缓存起来，较大的文件就会被放到磁盘缓存
- HTTP Cache：见网络基础中的 http 缓存策略
- Service Worker Cache：借助 Service Worker 实现的离线缓存
- Push Cache：HTTP2 在 server push 阶段存在的缓存，当前面的缓存都未命中时则询问 push cache，会话终止时缓存被释放；不同页面共享一个 http2 连接则共享一个 push cache

# HTTP 缓存策略
- 强缓存
  - Expires：资源过期时间，响应头返回，超过时间会重新请求资源
  - Cache-Control：
    - public：允许客户端、服务端缓存
    - private：允许浏览器缓存，禁止服务器缓存
    - no-cache：不取浏览器缓存，直接请求服务器确认资源过期情况
    - no-store：像代理服务器这类其他位置禁止缓存数据
    - max-age：单位秒，最大缓存到期时间
    - s-maxage：单位秒，代理的最大缓存到期时间
    - must-revalidate：过期后，必须从服务器请求验证，不能取缓存
 - 协商缓存
  - Last-Modified 和 If-Modified-Since：第一次请求返回响应头 Last-Modified，后续请求头中 If-Modified-Since 会将时间带到服务端，服务端判断在此时间之后资源有更新，则返回新资源并重新返回 Last-Modified，否则返回 304 表示可以取缓存
  - ETag 和 If-None-Match：第一次请求返回响应头 ETag，后续请求头中 If-None-Match 会带上之前的 ETag 发送到服务端，如果服务端 ETag 有变动，则返回新资源并返回新的 ETag

# Cookie
- 大小限制 4KB 左右
- 可设置生效时间
- 每次请求会带到 http 请求头中

# 加密
- 公钥：通过一种加密算法，生成的一对秘钥中的公开部分，用于对客户端数据进行加密
- 私钥：通过一种加密算法，生成的一对秘钥中的非公开部分，一般只有服务器知道，用于对客户端传递的加密数据进行解密
- 对称加密（私钥加密）：双方秘钥相同，都知道如何加密和解密，一旦秘钥被拦截则不安全
  - 浏览器给服务器发送一个随机数 client_random 和加密的方法列表
  - 服务器接收到后，会返回一个服务端的随机数 server_random 和使用的加密方法
  - 这样两边就拥有 client_random、server_random 和加密方法，用加密方法把随机数生成密钥
- 非对称加密（公钥加密）：双方都生成自己的公钥和私钥，解密方将公钥给加密方，然后加密方使用自己的公钥和对方的公钥加密数据（相当于一个两端带锁的桶型外壳，双方用自己的私钥都能解密）
- SSH 协议：使用对方的公钥加密数据后传递给对方，对方只有使用自己的私钥才能获取数据

# TLS（传输层安全协议）
- 位于传输层之上、应用层之下的安全协议
- TLS 握手过程（使用非对称加密生成秘钥，然后使用对称加密传输数据）：
  - 客户端：发送一个随机数和客户端需要的协议、支持的加密方式给服务端
  - 服务端：根据客户端需要的协议、加密方式，利用客户端的随机数和最优加密方式生成一个新的随机数，再把随机数和证书（公钥）发送给客户端
  - 客户端：收到服务端的公钥证书，使用公钥加密生成一个随机数发送给服务端，如果服务端要验证客户端证书，则还会发一个客户端的证书（公钥）给服务端
  - 服务端：收到客户端用服务端公钥加密的随机数，然后用自己的私钥解密获取原数据
  - 客户端和服务端：这时双方都有三个随机数，然后通过约定的加密方式，再进行加密生成最终的加密数据用的密钥，然后双方通信通过这个密钥来加密和解密数据

# SSL（安全套接层协议）
- SSL 及其继任者 TLS 是为网络通信提供安全及数据完整性的一种安全协议，TLS 与 SSL 在传输层对网络连接进行加密

# 客户端服务端双向通信
- http 短轮询：
  - 间隔特定时间发送一次请求获取资源
  - 缺点：资源浪费，给服务端造成压力
- http 长轮询：
  - 客户端发请求后，服务端保持连接，数据更新响应后才断开连接，然后客户端重新建立连接等待新数据
  - 缺点：重新建立连接过程中，页面上的数据可能已经不准确了
- xhr streaming：
  - 服务端不终止http响应流，一直处于连接状态，当有数据需要发送给客户端时，再写数据
  - 缺点：xmlhttprequest对象数据会不断增长，需要定期关闭连接处理缓冲区
- server-sent events：
  - 对 http 服务开一个持久化连接，以 text/event-stream 格式发送事件，会一直保持开启直到被要求关闭
- websocket：
  - 浏览器和服务端全双工通信，数据轻、效率高、性能开销低
  - 缺点：浏览器兼容，需要维护心跳和消息队列；
  
# 输入 url 到页面显示出来发生了什么
- get 请求，看是否命中强缓存
- dns 域名解析
  - 从浏览器缓存中获取
  - 从操作系统本地缓存（如：host 文件）中获取
  - 路由器缓存
  - 运营商 dns 缓存服务器（移动、联通、电信）
  - 根域名服务器
  - 顶级域名服务器
- 浏览器向目标 ip 服务器建立连接
  - 向服务器发起 TCP 连接请求
    - 三次握手建立连接
    - 传递数据包，接收方必须确认
    - 四次挥手断开连接
  - 如果需要 https 服务，则会继续建立 TLS 连接
- 发起 http 请求
  - 301（永久性转移）、302（暂时性转移）则重定向到目标网址；302 可能会因为某种规则还是显示原网址，这就容易造成 url 劫持，比如我可以利用 302 的规则让别人访问我的网址显示的是你网页的内容；
  - 304 获取缓存资源；
  - 400、500 报错；
  - 200 继续解析；
- 浏览器解析 html 代码
  - 根据 html 构建 dom 树
  - 加载 css，构建 cssom 树
  - 结合 dom 树 和 cssom 树，生成布局树 Layout Tree 用于对 dom 进行位置布局
  - 根据布局树建立图层树(Layer Tree)
  - 加载 js 脚本并顺序执行（执行过程会阻塞渲染）
  - 浏览器根据 render 树，调用 GPU 绘制合成图层，显示在屏幕上

# 网络攻击
- XSS 跨站脚本攻击：将代码注入到网页中
  - 反射型：在 url 上添加攻击代码作为参数
  - 文档型：在数据传输过程劫持到网络数据包，然后修改里面的 html 文档
  - 存储型：攻击脚本被写入数据库
  - 解决方案：
    - 对易造成威胁的 html 字符串，进行转义
    - 对于富文本这种标签很多的内容，过滤掉 script 这种容易注入脚本的标签
- CSP（内容安全策略）：建立白名单，让浏览器只允许加载安全的资源
  - 解决方案：
    - 设置 http header 中 content-security-policy 字段
    - 设置 meta 标签的 Content-Security-Policy 内容
      - 允许 http、https 的资源：`<meta http-equiv="Content-Security-Policy" content="default-src http: https:">`
      - 允许加载本站点资源：`<meta http-equiv="Content-Security-Policy" content="default-src \'self\'">`
      - 允许图片资源来自 https：`<meta http-equiv="Content-Security-Policy" content="img-src https:">`
      - 允许任何来源的资源：`<meta http-equiv="Content-Security-Policy" content="child-src \'none\'">`
      - 允许表单提交的目标服务是自身站点：`<meta http-equiv="Content-Security-Policy" content="form-action \'self\'">`
    - http header 为 Content-Security-Policy-Report-Only：不强制限制资源请求和提交，只报告问题，值和 Content-Security-Policy 相同；
- CSRF 跨站请求伪造：像钓鱼网站一样，注入诱导用户点击的链接入口触发请求，伪装成用户请求
  - 解决方案：
    - get 请求不用于修改数据
    - 阻止第三方网站访问用户 cookie
    - 阻止第三方网站请求接口
    - 请求时附带验证信息，如 token
    - 设置 cookie 的 SameSite 属性，禁止 cookie 数据随跨域请求发送
    - 对 Referer 做验证，判断其来源是否是第三方网站
- 点击劫持：攻击者将攻击网站嵌入到自己的网站中，并将自己网站透明，然后在自己的网站上利用按钮等诱导用户点击
  - 解决方案：
    - X-FRAME-OPTIONS：利用 http 头 X-FRAME-OPTIONS 配置来设置页面在 iframe 中的展示行为
    - 对于老浏览器，采用 js 操作：

    ```html
      <head>
        <style id="click-jack">
          html {
            display: none !important;
          }
        </style>
      </head>
      <body>
        <script>
          // 如果自身域不在顶层则将顶层访问自身的url，否则解除隐藏限制
          if (self == top) {
            var style = document.getElementById('click-jack')
            document.body.removeChild(style)
          } else {
            top.location = self.location
          }
        </script>
      </body>
    ```
中间人攻击：攻击方同时与客户端和服务端建立连接，用于获取双方的数据或修改数据后传递（例如 公共 wifi 容易发生此情况）
  - 解决方案：
    - 增加安全通道（如 https），然后关闭 http 的访问权限

# 解决开发调试时请求头未携带 Cookies
- 前端 ajax 增加配置：withCredentials: true，后端设置 response.setHeader("Access-Control-Allow-Credentials", "true")，将可以允许携带 Cookies；
