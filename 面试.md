# html
- 单页面和多页面区别（体验好，局部刷新，首屏加载慢）
- 如何提高 SEO（语义化标签、关键词 title、meta keywords、meta description、站点地图sitemap）

# css
- 盒模型
- 优先级（!important > 内联样式 > ID 选择器 > 类、伪类、属性选择器 > 元素、伪元素选择器）
- ICE（Inheritance 继承、Cascade 层叠、Explicitness 显式性）
- 内联元素和块元素
- 定位属性的区别
- 怎么实现居中
- 浮动是什么，有什么作用
- demo：写一个三边带阴影的三角形（canvas、div加伪类）
- demo：实现一个正六边形（canvas、div拼接）
- demo：让一行三个相等半径的圆，能随所在容器的宽度变化，而自适应（用 padding 相对自身宽度百分比）

# js
- 对象类型和基本类型有哪些，两者的区别
- 原型、原型链、继承
- 作用域、上下文
- 闭包（访问其他作用域的方式）
- 异步、同步的区别
- 事件冒泡、捕获
- 模块化（CommonJS、AMD、CMD、ES6、UMD）
- MVC（Model-View-Controller）、MVVM（Model-View-ViewModel）是什么
- 本地缓存（localStorage 和 sessionStorage）

# es6 新特性
- let、const、var 区别
- 箭头函数的作用
- 解构赋值
- 模板字符串
- 展开运算符（...args）
- async/await
- 类（Class）、继承
- 模块化（import/export）
- Set/Map/WeakSet/WeakMap
- Symbol 类型
- 迭代器（Iterator）、生成器（Generator）
- Proxy、Reflect
- 新的内置方法和对象（Object.assign、Array.from）
- Module 的静态分析

# http
- get 和 post请求区别
- 跨域
- 常见响应状态码
- 一次 http 请求过程

# 移动端h5
- 为什么要做适配
- 响应式布局怎么实现
- 1px border 怎么实现

# jquery
- jquery 和 vue 区别

# vue2
- 生命周期函数执行顺序（beforeCreate、created、beforeMount、mounted、beforeUpdate、updated、beforeDestroy、destroyed）
- v-show 和 v-if 的区别
- computed 和 watch 的区别
- 组件数据通信（props 和 $emit；provide 和 inject；$on 和 $emit）
- keep-alive 的作用
- slot 插槽有哪些类型（默认、具名、作用域）
- $set 的作用
- Vue.nextTick 的作用
- Vue.extend 的作用
- render 和模版的区别
- 虚拟 dom 作用（多端、对比减少 dom 频繁执行）
- v-for 中使用 key 属性的作用
- vue 项目是怎么避免样式污染的（scoped）

# vue-router
- 配置中 mode 的 hash 和 history 的区别
- 跳转路由的方式（push、replace）

# vuex
- mutations 和 actions 区别

# vue3
- 响应式原理（Proxy 替代 Object.defineProperty）
- 组件式 Composition API
- 生命周期变化（如：onMounted、onUnmounted、onBeforeMount、onBeforeUnmount、onUpdated、onBeforeUpdate、onErrorCaptured）
- script setup 中能通过 this 访问到组件实例吗
- 内置新组件（Teleport 传送门 Suspense 异步组件处理）
- Fragment 无根节点限制
- 创建 app 方式变化 createApp、全局 API（app.config.globalProperties、app.use、app.component 等）
- v-model 语法的变化（多 v-model 支持，modelModifiers）
- TypeScript 支持增强
- 性能优化（编译优化、Tree shaking 更彻底）

# 跨端技术（跨小程序、原生、web等）
- 哪些技术（React Native、Flutter、uni-app、Taro、H5+原生混合开发等）
- 优缺点（代码复用率高、开发成本低、性能不如原生）
- 技术的原理（RN 的 JSBridge、Flutter 的渲染引擎、uni-app 的编译转译机制）
- 什么时候用跨端技术，什么时候用原生开发

# 应用解决方案
- 避免代码高频率执行：防抖、截流
- 如何优化首屏加载：路由懒加载、异步组件

# 微前端
- 什么是微前端，好处和坏处（一个前端应用拆分成多个独立开发部署）
- 用过哪些微前端库？无界，乾坤
- 主应用和子应用的通信方式（postMessage、url 参数传递）
- 样式隔离和 JS 隔离如何解决（原生Shadow DOM、CSS 前缀、动态 CSS-in-JS）
- 微前端下全局状态如何管理（主应用和子应用通过通信同步状态数据）

# 项目工程化
- 构建工具有哪些（webpack、vite、rollup、gulp）
- 使用构建工具打包的好处（tree shaking、按需加载、代码分割、懒加载、代码压缩）
- source map 的作用

# 怎么写一个好代码
- 注释写清楚；
- 变量名，方法名语意化；
- 控制文件代码行数；
- 代码复用，组件化；

# 用过哪些 AI 产品，用到哪些场景
- cursor
- chatgpt
- claude code
- deepseek