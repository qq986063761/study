# 跨 iframe 方法传递方案

## 问题

`postMessage` API 无法直接传递函数，因为函数无法被结构化克隆算法序列化。错误信息：
```
Failed to execute 'postMessage' on 'MessagePort': function could not be cloned.
```

## 解决方案

### 方案1: 回调 ID 机制（推荐）⭐

**原理**：将回调函数存储在本地池中，传递唯一的回调 ID，对方通过 ID 调用回调。

**优点**：
- 简单直观
- 支持多次调用
- 可以传递参数
- 易于实现

**实现步骤**：

1. **父应用（主窗口）**
```javascript
// 回调函数池
const callbackPool = new Map()
let callbackIdCounter = 0

// 注册回调
function registerCallback(callback) {
  const id = `cb_${++callbackIdCounter}_${Date.now()}`
  callbackPool.set(id, callback)
  return id
}

// 执行回调（供子应用调用）
methods: {
  executeCallback(callbackId, ...args) {
    const callback = callbackPool.get(callbackId)
    if (callback) {
      return callback(...args)
    }
  }
}

// 使用
const callbackId = registerCallback((result) => {
  console.log('回调被调用', result)
})

remote.showModal({
  title: '测试',
  callbackId: callbackId  // 传递 ID 而不是函数
})
```

2. **子应用（iframe）**
```javascript
methods: {
  showModal(opts) {
    const { title, callbackId } = opts
    
    // 异步操作后调用回调
    setTimeout(() => {
      remoteParent.executeCallback(callbackId, {
        success: true,
        data: '结果数据'
      })
    }, 1000)
  }
}
```

---

### 方案2: Promise 包装

**原理**：将异步操作包装成 Promise，返回 Promise 给调用方。

**优点**：
- 符合现代异步编程习惯
- 支持 async/await
- 自动处理错误

**实现**：

```javascript
// 子应用
methods: {
  showModal(opts) {
    return new Promise((resolve, reject) => {
      // 显示弹窗
      showModalUI(opts)
      
      // 用户操作后 resolve/reject
      window.onConfirm = () => resolve({ success: true })
      window.onCancel = () => reject(new Error('用户取消'))
    })
  }
}

// 父应用
try {
  const result = await remote.showModal({ title: '测试' })
  console.log('成功', result)
} catch (error) {
  console.error('失败', error)
}
```

---

### 方案3: 事件系统

**原理**：使用事件名来标识不同的回调，通过事件系统通信。

**优点**：
- 解耦
- 支持一对多通信
- 易于扩展

**实现**：

```javascript
// 父应用
const eventBus = {
  listeners: new Map(),
  on(event, callback) {
    if (!this.listeners.has(event)) {
      this.listeners.set(event, [])
    }
    this.listeners.get(event).push(callback)
  },
  emit(event, ...args) {
    const callbacks = this.listeners.get(event) || []
    callbacks.forEach(cb => cb(...args))
  }
}

// 注册事件监听
eventBus.on('modal:confirm', (result) => {
  console.log('确认', result)
})

// 传递事件名
remote.showModal({
  title: '测试',
  confirmEvent: 'modal:confirm'  // 事件名
})

// 子应用
methods: {
  showModal(opts) {
    const { title, confirmEvent } = opts
    
    // 用户确认后发送事件
    setTimeout(() => {
      remoteParent.emitEvent(confirmEvent, { success: true })
    }, 1000)
  }
}
```

---

## 方案对比

| 方案 | 复杂度 | 适用场景 | 推荐度 |
|------|--------|----------|--------|
| 回调 ID | ⭐⭐ | 简单回调、多次调用 | ⭐⭐⭐⭐⭐ |
| Promise | ⭐⭐⭐ | 异步操作、现代代码 | ⭐⭐⭐⭐ |
| 事件系统 | ⭐⭐⭐⭐ | 复杂通信、多对多 | ⭐⭐⭐ |

## 最佳实践

1. **简单回调**：使用回调 ID 机制
2. **异步操作**：使用 Promise 包装
3. **复杂通信**：结合使用回调 ID + 事件系统

## 注意事项

1. **内存泄漏**：回调池需要及时清理不需要的回调
2. **安全性**：验证回调 ID 的有效性
3. **超时处理**：为回调设置超时机制
4. **错误处理**：处理回调不存在的情况

## 完整示例

查看 `penpal-advanced.html` 和 `penpal-child-advanced.html` 获取完整实现。
