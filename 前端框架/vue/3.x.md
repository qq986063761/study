# 资源
- [pinia](https://pinia.vuejs.org/zh/)

# 和 vue2 的区别

## 核心架构变化
- **响应式系统重构**：通过 Proxy 重新设计响应式，渲染性能更好，支持动态属性监听
- **组合式 API**：让逻辑复用更好，代码组织也方便，解决了 vue2 中 mixin 的变量冲突和来源不清楚的问题
- **TypeScript 原生支持**：完全使用 TypeScript 重写，提供更好的类型推断和开发体验

## 性能优化
- **打包体积减少**：Tree-shaking 打包移除未使用代码，仅打包实际使用的模块
- **编译优化**：
  - 静态元素提升（Static Hoisting）
  - 虚拟节点静态标记（Patch Flag）
  - 事件处理函数缓存（Cache Handler）
- **SSR 渲染性能提升**：服务器端渲染速度提高 2-3 倍
- **Fragment 支持**：模版支持多个根节点，减少不必要的包装元素

## 模板和指令变化
- **v-if 和 v-for 优先级**：Vue 3 中 v-if 优先级高于 v-for
- **移除过滤器（Filters）**：不再支持 `{{ value | filter }}` 语法，推荐使用计算属性或方法
- **移除 `.sync` 修饰符**：使用 `v-model` 替代

## 生命周期变化
- **生命周期钩子重命名**：
  - `beforeDestroy` → `beforeUnmount`
  - `destroyed` → `unmounted`
- **组合式 API 中的生命周期**：需要显式导入，如 `onMounted`、`onUnmounted`

## 新增特性
- **新内置组件**：
  - `Teleport`：可将组件内容渲染到 DOM 任意位置
  - `Suspense`：处理异步组件加载的占位内容
- **新指令**：`v-memo` 用于缓存模板片段
- **新 API**：`defineAsyncComponent`、`defineEmits`、`defineProps` 等

## 移除的特性
- **事件总线**：移除 `$on`、`$off`、`$once` 实例方法
- **过滤器**：完全移除过滤器功能
- **全局 API 变化**：`Vue.extend`、`Vue.component` 等全局 API 改为应用实例方法
- **`.sync` 修饰符**：使用 `v-model` 替代
- **`$children` 和 `$listeners`**：移除这些实例属性

# 性能提升详解

## 响应式系统优化
- **Vue 2.x**：使用 `Object.defineProperty` 深度遍历劫持对象所有属性实现响应式
- **Vue 3.x**：使用 `Proxy` 对象重写响应式系统
  - 可监听动态新增的属性，和删除属性
  - 可监听数组索引和 length 变化
  - 性能提升：初始化速度提升 1.3-2 倍

## 编译时优化
- **Vue 2.x**：标记静态节点，优化 diff 过程
- **Vue 3.x** 编译优化：
  - **静态提升（Static Hoisting）**：所有静态节点提升到 render 方法外，只会在应用启动时创建一次
  - **Patch Flag**：在动态标签末尾加上相应标记，只有带 patchFlag 的节点才被认为是动态元素，快速定位变化
  - **事件处理函数缓存**：避免每次触发都重新生成新函数
  - **Fragments 支持**：template 中可不要唯一根节点，减少包装元素

## 代码体积优化
- **Tree-shaking**：函数只有用到才会打包，编译阶段静态分析，未引入的模块会被移除
- **模块化设计**：移出一些不常用的 API，按需引入
- **体积减少**：相比 Vue 2 减少约 41% 的打包体积

# 新组件详解

## Fragment（片段）
- **作用**：可以不用根标签，内容会包含在 Fragment 虚拟元素中
- **优势**：减少标签层级和内存占用
- **使用场景**：多根节点组件，避免不必要的包装元素

## Teleport（传送门）
- **作用**：可将组件 HTML 内容渲染到 DOM 中的任意位置
- **使用场景**：模态框、通知、下拉菜单等需要脱离当前组件层级的场景
- **语法**：`<Teleport to="body">...</Teleport>`

## Suspense（异步组件）
- **作用**：处理异步组件加载时的占位内容，优化用户体验
- **使用场景**：懒加载组件、异步数据获取等
- **语法**：配合 `defineAsyncComponent` 使用

# 生命周期详解

## 选项式 API 生命周期
- **beforeCreate**：初始化选项之前触发
- **created**：初始化完成后触发，数据可访问，组件未挂载到 DOM
- **beforeMount**：创建和插入 DOM 节点之前触发
- **mounted**：DOM 节点渲染完成后触发
- **beforeUpdate**：虚拟 DOM 重新渲染和打补丁之前触发
- **updated**：虚拟 DOM 重新渲染和打补丁之后触发
- **beforeUnmount**：组件被销毁前触发（Vue 2 中为 beforeDestroy）
- **unmounted**：组件销毁后触发（Vue 2 中为 destroyed）

## 组合式 API 生命周期
- **onBeforeMount**：需要显式导入
- **onMounted**：需要显式导入
- **onBeforeUpdate**：需要显式导入
- **onUpdated**：需要显式导入
- **onBeforeUnmount**：需要显式导入
- **onUnmounted**：需要显式导入
- **onActivated**：keep-alive 组件激活时
- **onDeactivated**：keep-alive 组件失活时

# 组合式 API 核心概念

## ref 和 reactive 区别
### ref
- 主要用于**基本类型数据**（如 number、string、boolean），也能包裹对象类型
- 使用 `ref` 创建的变量，**必须通过 `.value` 访问和修改**，模板中可省略 `.value`
- 可以重新赋值整个基本类型或对象
- 包裹对象时，实际取值和操作也需要 `.value`，但对象属性依旧具备响应式特性
- 适用于单个值或要频繁替换整个对象的场景

### reactive
- 只能用于**对象类型**（包括 Object、Array、Map、Set 等）
- 创建对象响应式以后，**无需 `.value`，直接使用属性**
- **不能替换整个对象本身**。如果直接赋值，会失去响应性。应通过属性赋值或 `Object.assign` 重置内容
- 适用于管理状态复杂、结构丰富的数据对象

## 重要 API 变化
### 新增 API
- **defineProps**：定义组件 props
- **defineEmits**：定义组件 emits
- **defineExpose**：暴露组件实例方法
- **defineAsyncComponent**：定义异步组件
- **withDefaults**：为 defineProps 提供默认值
- **v-memo**：缓存模板片段

### 全局 API 变化
- **Vue.createApp()**：替代 `new Vue()`
- **app.component()**：替代 `Vue.component()`
- **app.directive()**：替代 `Vue.directive()`
- **app.use()**：替代 `Vue.use()`

## 迁移注意事项
### 破坏性变化
- **过滤器移除**：使用计算属性或方法替代
- **事件总线移除**：使用 provide/inject 或状态管理
- **$children 移除**：使用 ref 获取子组件
- **$listeners 移除**：使用 v-on="$attrs" 替代
- **.sync 修饰符移除**：使用 v-model 替代

### 推荐迁移路径
1. **渐进式迁移**：可以同时使用选项式 API 和组合式 API
2. **使用 `<script setup>`**：简化组合式 API 语法
3. **使用 Pinia**：替代 Vuex 进行状态管理
4. **使用 Vite**：替代 Vue CLI 获得更好的开发体验
